# Java 继承 - 思维导图

## 一、继承的核心定义

1. **概念**
    - Java 中一种**类与类之间的关系**，子类（派生类）通过特定语法获取父类（超类 / 基类）的属性和方法
    - 满足 “is-a” 逻辑（例：Dog **is a** Animal，Student **is a** Person）
2. **本质**
    - 解决**代码复用**（避免重复编写父类的共性代码）
    - 建立**类的层次结构**（从通用到具体，如 “生物→动物→哺乳动物→狗”）
3. **核心作用**
    - 复用父类的成员（成员变量、成员方法）
    - 扩展父类功能（子类可新增属性 / 方法，或重写父类方法）

## 二、继承的语法规则

1. **关键字**
    - 子类定义时用 `extends` 关联父类，格式：`class 子类名 extends 父类名 {}`
    - 例：`class Dog extends Animal {}`（Dog 是子类，Animal 是父类）
2. **类的角色**
    - 父类（超类 / 基类）：被继承的类，包含共性属性 / 方法（例：Animal 有 `name`、`age`、`eat()`）
    - 子类（派生类）：继承父类的类，可新增特性（例：Dog 新增 `bark()` 方法）
3. **基础示例**
    
    Java
    
    运行
    
    ```java
    // 父类
    class Animal {
        String name;
        void eat() {
            System.out.println(name + "在吃东西");
        }
    }
    // 子类
    class Dog extends Animal {
        // 新增方法
        void bark() {
            System.out.println(name + "在叫：汪汪！");
        }
    }
    ```
    
      
    

## 三、继承的核心特性

1. **单继承限制**
    - Java**不支持多继承**（子类只能继承 1 个父类），避免 “菱形继承” 冲突（例：A 同时继承 B 和 C，B 和 C 都有 `method()`，A 无法确定调用哪个）
    - 替代方案：通过**接口多实现**（`class A implements B, C`）弥补多继承需求
2. **继承的传递性**
    - 若 A 继承 B，B 继承 C，则 A**间接继承 C 的非私有成员**（例：A→B→C，A 可调用 C 的 `method()`）
    - 例：`class Mammal extends Animal`，`class Dog extends Mammal` → Dog 间接继承 Animal
3. **成员访问规则**
    
    |成员类型|子类访问权限|
    |---|---|
    |父类 public 成员|子类可直接访问（无论子类和父类是否在同一包）|
    |父类 protected 成员|子类可直接访问（同一包内，或不同包的子类）|
    ==`|父类 default 成员|子类仅能在**同一包内**访问|`==
    |父类 private 成员|子类**不可直接访问**（需通过父类的 public/getter/setter 方法间接访问）|
    

## 四、继承的关键规则（重难点）

### 1. Super 关键字

- **作用**：在子类中访问父类的成员（成员变量、成员方法、构造器）
    
- **3 种核心用法**：  
    ① 访问父类成员变量：`super.父类变量名`（解决 “子类与父类变量重名” 冲突）  
    例：子类有 `String name`，父类也有 `String name` → 用 `super.name` 访问父类的 name  
    ② 调用父类成员方法：`super.父类方法名(参数)`（子类未重写时可省略，重写后需显式调用父类方法）  
    例：子类重写 `eat()` 后，用 `super.eat()` 调用父类的 `eat()`  
    ③ 调用父类构造器：`super(参数)`（必须放在子类构造器的**第一行**）  
    例：父类有 `Animal(String name)`，子类构造器中用 `super("旺财")` 调用父类构造器
    
- **注意**：`super` 不能在静态方法中使用（静态方法属于类，不依赖对象，而 `super` 依赖父子对象关系）
    

### 2. 方法重写（Override）

- **定义**：子类定义与父类**方法名、参数列表、返回值类型（兼容）** 完全一致的方法，覆盖父类方法的实现
- **核心要求**：  
    ① 方法签名（方法名 + 参数列表）必须完全一致（参数个数、类型、顺序都要相同）  
    ② 返回值类型：子类方法返回值需是父类方法返回值的**子类或相同类型**（“协变返回值”）  
    ③ 访问权限：子类方法的访问权限**不能低于**父类方法（例：父类是 protected，子类可是 protected/public，不能是 default/private）  
    ④ 不能重写的方法：
    - 父类 private 方法（子类看不见，无法重写）
    - 父类 static 方法（子类若定义同名 static 方法，是 “方法隐藏”，不是重写）
    - 父类 final 方法（final 修饰的方法禁止重写）
- **示例**：
    
    Java
    
    运行
    
    ```java
    class Animal {
        void eat() { System.out.println("吃食物"); }
    }
    class Dog extends Animal {
        // 重写父类eat()
        @Override // 注解：校验是否符合重写规则（可选，但推荐加）
        void eat() { System.out.println("吃骨头"); }
    }
    ```
    
      
    

### 3. 构造器的继承规则

- **核心原则**：子类构造器**默认调用父类的无参构造器**（隐式调用 `super()`）
- **关键场景**：  
    ① 父类有**无参构造器**（默认或手动定义）：子类构造器无需显式调用 `super()`，JVM 自动添加  
    ② 父类**没有无参构造器**（仅定义了有参构造器）：子类构造器**必须显式调用父类的有参构造器**（用 `super(参数)`），否则编译报错
- **示例**：
    
    Java
    
    运行
    
    ```java
    // 父类（无无参构造器）
    class Animal {
        Animal(String name) { // 仅有参构造器
            this.name = name;
        }
    }
    // 子类（必须显式调用父类有参构造器）
    class Dog extends Animal {
        Dog() {
            super("旺财"); // 必须放在第一行，调用父类的Animal(String)
        }
    }
    ```
    
      
    

### 4. Final 关键字与继承

- **final 修饰类**：类**不能被继承**（例：`final class String`，String 类无法被继承）
- **final 修饰方法**：方法**不能被子类重写**（例：父类 `final void method()`，子类无法重写该方法）
- **final 修饰变量**：变量为常量（值不可变），但**不影响继承**（子类可访问父类的 final 变量，只是不能修改）

## 五、继承的使用场景

1. **共性抽取**：多个类存在相同的属性 / 方法时，抽取为父类（例：Student 和 Teacher 都有 `name` / `age`，抽取为 Person 父类）
2. **功能扩展**：基于已有类新增功能，无需修改原类（符合 “开闭原则”）  
    例：已有 `ArrayList` 类，需新增 “按条件过滤元素” 功能 → 定义 `FilterArrayList extends ArrayList`，新增 `filter()` 方法
3. **层次建模**：需要建立类的层级关系，体现 “通用→具体” 的逻辑（例：电商系统中，`Goods` → `Electronics` → `Phone`）

## 六、继承的注意事项与常见问题

1. **避免过度继承**：继承层级过深（如 A→B→C→D→...）会导致代码耦合高、可读性差，建议层级控制在**3 层以内**
2. **“is-a” 关系校验**：仅当子类与父类确实是 “从属关系” 时才用继承，避免为了复用代码强行继承（例：`Bird` 继承 `Airplane` 错误，因为 Bird 不是 Airplane；`Bird` 继承 `Animal` 正确）
3. **子类不可直接访问父类 private 成员**：需通过父类的 public/getter/setter 方法间接访问（例：父类 `private String name`，子类用 `super.getName()` 获取 name）
4. **静态方法不能重写**：子类若定义与父类同名的静态方法，是 “方法隐藏”（调用时取决于 “类名”，而非对象类型），不是重写  
    例：父类 `static void method()`，子类 `static void method()` → 调用 `父类.method()` 执行父类方法，`子类.method()` 执行子类方法

## 七、继承与其他特性的关联

1. **继承与多态**：继承是多态的前提（多态需 “子类继承父类 + 方法重写”，通过父类引用指向子类对象实现）
2. **继承与抽象类**：抽象类通常作为 “父类” 使用（定义通用接口，由子类实现具体方法），例：`abstract class Shape`，子类 `Circle` / `Rectangle` 继承并实现 `getArea()`
3. **继承与接口**：接口不能被继承（但可被 “实现”），子类可通过 “继承类 + 实现接口” 组合（例：`class Dog extends Animal implements Runnable`）