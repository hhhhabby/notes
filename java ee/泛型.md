 ![[Pasted image 20250926201237.png]]
 强转代码：
 
 
 **是否需要定界？** 
 不需要。大多数泛型（如`ArrayList<T>`、`Box<T>`）都不带定界，默认适配所有引用类型。
- **怎么知道泛型能通用什么类型？**
    - 若未指定定界：通用所有引用类型（`String`、`Integer`、自定义类等，基本类型需用包装类）。
    - 若指定了上界（`T extends A`）：只能是`A`或`A`的子类 / 实现类。
    - 若指定了下界（`<? super A>`）：只能是`A`或`A`的父类。
- **判断是否需要定界的简单原则**：看你的代码中是否用到了泛型类型的**特定方法 / 特性**。用到了就加对应定界，没用到就不用加。
# 泛型限制
擦除后看是不是实例化
静态变量不能泛型化

擦除后是 object




### 核心限制及原因（基于类型擦除）

Java 泛型在**编译后会被 “擦除”**：泛型参数的具体类型信息会被丢弃，
只保留 “原始类型”（比如`List<String>`擦除后变为`List`，`T extends Number`擦除后变为`Number`）。这种设计导致了以下限制：

#### 1. 不能用基本类型作为泛型参数

泛型参数必须是**引用类型**（如`String`、`Integer`），不能是基本类型（`int`、`double`等）。

因为类型擦除后，泛型的底层会用`Object`（或上界类型）存储数据，而基本类型不是`Object`的子类，无法直接适配。

**错误示例**：

java

运行

```java
List<int> list = new ArrayList<>(); // 编译报错！不能用int（基本类型）
List<Integer> list = new ArrayList<>(); // 正确：用包装类（引用类型）
```

#### 2. 不能实例化泛型类型（`new T()`）

无法直接创建泛型参数`T`的实例（如`new T()`）。

因为类型擦除后，`T`会被替换为`Object`（或上界类型），编译器无法确定`T`的具体类型，也就无法调用其构造方法。

**错误示例**：

java

运行

```java
class Box<T> {
    public Box() {
        T value = new T(); // 编译报错！无法实例化T
    }
}
```

**替代方案**：通过反射间接创建（需传入`Class`对象）：

java

运行

```java
class Box<T> {
    public T create(Class<T> clazz) throws Exception {
        return clazz.newInstance(); // 用反射创建实例
    }
}
```

#### 3. 静态成员不能使用泛型类型参数

类的静态成员（变量、方法）不能直接使用泛型类的类型参数`T`。

因为静态成员属于 “类级别”，在类加载时就已存在，而泛型的具体类型`T`是在**实例化时**才确定的（不同实例的`T`可能不同），两者矛盾。

**错误示例**：

java

运行

```java
class Box<T> {
    public static T value; // 编译报错！静态变量不能用T
    public static T getValue() { return null; } // 编译报错！静态方法不能用T
}
```

#### 4. 不能创建泛型数组（`new T[]`）

无法直接创建泛型数组（如`new T[10]`）。

因为类型擦除后，数组的实际类型会变为`Object[]`，而 Java 数组会在运行时检查元素类型，此时若存入其他类型会导致异常（破坏类型安全）。

**错误示例**：

java

运行

```java
class Box<T> {
    public void method() {
        T[] arr = new T[10]; // 编译报错！不能创建T[]
    }
}
```

**替代方案**：创建`Object[]`后强转（需谨慎，可能有安全隐患）：

java

运行

```java
T[] arr = (T[]) new Object[10]; // 可以编译，但需注意类型安全
```

#### 5. 泛型类不能继承`Throwable`（异常类）

不能定义泛型异常类（如`class MyException<T> extends Exception`）。

因为异常处理（`try-catch`）需要在编译时确定具体类型，而泛型擦除会导致运行时无法识别`T`的类型，破坏异常处理逻辑。

**错误示例**：

java

运行

```java
class MyException<T> extends Exception { } // 编译报错！
```

#### 6. 通配符`?`不能用于赋值或作为返回值类型

通配符`?`（表示 “未知类型”）只能用于 “读取” 场景，不能直接赋值或作为方法返回值类型。

因为`?`的类型不确定，编译器无法保证赋值的安全性。

**错误示例**：

java

运行

```java
List<?> list = new ArrayList<String>();
list.add("hello"); // 编译报错！不能向?的集合添加元素（类型不确定）
```

### 总结
泛型的限制主要源于**类型擦除**（编译后丢失具体类型信息）和 Java 类型系统的设计约束。核心目的是在 “通用性” 和 “类型安全” 之间做平衡。记住这些限制，能避免在实际开发中写出编译错误或运行时异常的代码。