
```java
import java.util.Arrays;

public class SortedSeqList {
    private int[] elem;  // 存储元素的数组
    private int length;  // 当前元素个数

    // 构造函数：初始化容量为100的顺序表
    public SortedSeqList() {
        elem = new int[100];
        length = 0;
    }

    // 有序插入元素（保持非递减）
    public boolean insert(int e) {
        // 扩容：元素满时容量翻倍
        if (length == elem.length) {
            elem = Arrays.copyOf(elem, elem.length * 2);
        }

        // 查找插入位置
        int insertIdx = 0;
        while (insertIdx < length && elem[insertIdx] <= e) {
            insertIdx++;
        }

        // 元素后移
        for (int i = length; i > insertIdx; i--) {
            elem[i] = elem[i - 1];
        }

        // 插入元素并更新长度
        elem[insertIdx] = e;
        length++;
        return true;
    }

    // 修正后的print方法：打印所有元素
    public void print() {  // 补充括号()
        for (int i = 0; i < length; i++) {
            System.out.print(elem[i] + " ");  // 打印元素，用空格分隔
        }
        System.out.println();  // 打印完换行
    }

    // 测试代码
    public static void main(String[] args) {
        SortedSeqList list = new SortedSeqList();
        list.insert(20);
        list.insert(10);
        list.insert(30);
        list.insert(15);
        list.print();  // 输出：10 15 20 30 
    }
}
```

对比增加 删除最后一个下标的的有序顺序表和链表

要清晰对比**有序顺序表**与**有序链表**在 “增加元素” 和 “删除最后一个元素（尾删）” 操作的差异，需先明确二者的存储本质，再从**操作步骤、时间复杂度、空间开销、核心特点**四个维度展开分析。

### 一、基础概念界定

在对比前，先明确两种数据结构的核心特征（均为**有序结构**，即元素按指定规则排序，操作需保持有序性）：

|数据结构|存储方式|核心特性|访问方式|
|---|---|---|---|
|有序顺序表|连续内存（数组）|支持随机访问（通过索引直接定位）|随机访问（O (1)）|
|有序链表|离散节点（数据 + 指针）|不支持随机访问，依赖指针遍历|顺序访问（O (n)）|
|（链表细分）|- 单链表：仅存`next`指针|无法直接访问前驱节点|顺序访问|
||- 双链表：存`prev+next`|可直接访问前驱 / 后继节点|顺序访问|
||- 带尾指针：额外存`tail`|优化尾插操作，需结合链表类型判断|顺序访问|

## 二、对比 1：增加元素（保持有序）

### 具体解释：

1. **链表的增删操作本身（已知位置时）**
2. **“查找目标位置” 的时间复杂度是 O (n)**

有序结构的 “增加” 并非简单追加，需先找到**插入位置**（确保插入后仍有序），再执行插入。二者的核心差异体现在 “查找位置” 和 “元素移动 / 指针修改” 的效率上。

### 1.1 操作对比表

| 数据结构类型      | 操作核心步骤                                                                                                             | 时间复杂度（总）               | 空间开销                                 | 关键注意点                                                        |
| ----------- | ------------------------------------------------------------------------------------------------------------------ | ---------------------- | ------------------------------------ | ------------------------------------------------------------ |
| 有序顺序表       | 1. 二分查找插入位置（O (logn)）；<br><br>2. 若数组满，触发扩容（复制原数组，O (n)）；<br><br>3. 插入位置后元素集体后移（O (n)）；<br><br>4. 插入新元素，`length+1`。 | 平均 O (n)；最坏 O (n)（需扩容） | 扩容时额外消耗 O (n)（新数组）；基本插入无额外空间（除新元素本身） | 扩容是 “amortized O (1)”（多次插入分摊扩容开销），但单次扩容仍为 O (n)；后移元素是主要时间开销。 |
| 有序单链表（无尾指针） | 1. 从头遍历，找第一个大于新元素的节点的前驱（O (n)，无法二分）；<br><br>2. 新建节点；<br><br>3. 修改前驱`next`指向新节点，新节点`next`指向原后继（O (1)）。              | O(n)                   | 新节点内存（O (1) per 插入）                  | 遍历是唯一时间开销；无需移动元素，仅修改指针。                                      |
| 有序双链表（带尾指针） | 1. 可从头 / 尾遍历找插入位置（优化但仍需 O (n)）；<br><br>2. 新建节点；<br><br>3. 修改前驱`next`和后继`prev`（O(1)）。                               | O(n)                   | 新节点内存（O (1) per 插入）                  | 双链表仅优化指针修改步骤，无法优化 “查找位置”（仍需顺序遍历）。                            |

### 1.2 核心差异总结

- **时间开销原因不同**：有序顺序表的 O (n) 来自 “元素后移”，有序链表的 O (n) 来自 “遍历找位置”；
- **空间灵活性不同**：顺序表依赖数组容量，扩容会浪费临时空间；链表按需分配节点，空间更灵活；
- **查找效率不同**：顺序表可二分查找（O (logn)），但被后移的 O (n) 掩盖；链表只能顺序查找（O (n)），无优化空间。

## 三、对比 2：删除最后一个元素（尾删）

尾删的核心是 “定位尾元素的前驱”，二者的差异完全由**存储方式**决定（连续内存 vs 离散节点），且链表类型（单 / 双、有无尾指针）对效率影响极大。

### 2.1 操作对比表

|数据结构类型|操作核心步骤|时间复杂度|空间开销|关键注意点|
|---|---|---|---|---|
|有序顺序表|1. 检查`length>0`；<br><br>2. 直接将`length-1`（无需移动元素，后续访问以`length`为界）；<br><br>3. （可选）若`length`远小于容量，触发缩容（O (n)，极少用）。|基本 O (1)；最坏 O (n)（缩容）|缩容时额外消耗 O (n)；基本操作无|效率极高，因尾元素位置固定（`index=length-1`），仅需修改长度变量。|
|有序单链表（无尾指针）|1. 检查`head`是否为空；<br><br>2. 从头遍历到倒数第二个节点（O (n)，需定位前驱）；<br><br>3. 置前驱`next=null`；<br><br>4. 删除原尾节点。|O(n)|无额外开销|必须遍历到前驱，是单链表尾删的致命瓶颈。|
|有序单链表（带尾指针）|1. 检查`tail`是否为空；<br><br>2. 仍需遍历到倒数第二个节点（O (n)，`tail`无法直接获取前驱）；<br><br>3. 置前驱`next=null`，更新`tail`为前驱；<br><br>4. 删除原尾节点。|O(n)|无额外开销|尾指针仅优化 “尾插”，对 “尾删” 无效（本质是单链表无前驱指针）。|
|有序双链表（带尾指针）|1. 检查`tail`是否为空；<br><br>2. 通过`tail.prev`直接获取前驱（O (1)）；<br><br>3. 置前驱`next=null`，更新`tail`为前驱；<br><br>4. 删除原尾节点。|O(1)|无额外开销|依赖双链表的`prev`指针，直接定位前驱，彻底解决尾删效率问题。|

### 2.2 核心差异总结

- **顺序表碾压单链表**：顺序表尾删是 O (1)，单链表（无论有无尾指针）必为 O (n)；
- **双链表追平顺序表**：双链表（带尾指针）通过`prev`指针实现 O (1) 尾删，与顺序表效率一致；
- **空间优化不同**：顺序表可通过缩容优化空间（但代价 O (n)），链表无需缩容（节点直接删除回收）。

## 四、整体结论与适用场景

|场景需求|优先选择|核心原因|
|---|---|---|
|频繁尾删 + 无需频繁扩容|有序顺序表|尾删 O (1)，实现简单，随机访问能力可复用（如后续需按索引查询）。|
|频繁尾删 + 频繁动态扩容|有序双链表（带尾）|避免顺序表扩容的 O (n) 开销，尾删仍保持 O (1)，空间分配更灵活。|
|极少尾删 + 频繁增加|均可（按需选择）|增加操作均为 O (n)，顺序表胜在随机访问，链表胜在空间灵活。|
|禁止内存浪费（如嵌入式场景）|有序双链表（带尾）|无扩容导致的内存冗余，节点按需分配，尾删效率有保障。|

**一句话核心**：尾删效率是二者关键分水岭 —— 顺序表和双链表（带尾）是 O (1)，单链表是 O (n)；增加操作二者均为 O (n)，但瓶颈来源不同（顺序表后移 vs 链表遍历）。