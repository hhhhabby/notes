1. 操作的什么？
对头和队尾

2. 顺序对列的假溢出
如果用动态数组解决，也会出现往后，多几个的时候。假溢出问题。







# 要判断基于数组实现的循环队列是否为满 #flashcard
### **空一位法**
数组实现的队列通常采用**循环队列**结构（避免数组空间浪费），其核心约定为：

- `front` 指向队头元素的位置；
- `rear` 指向队尾元素的**下一个位置**（即下一个待插入元素的位置）；
- 为区分 “队列空” 和 “队列满”，会**预留一个空闲位置**
- ==（即队列最大存储元素数为 `capacity - 1`）==

### 判断队列满的条件示例代码

当队尾的下一个位置==（循环后）==与队头位置重合时，队列已满。用公式表示为：

```java
public boolean isFull() {
    return (rear + 1) % capacity == front;
}
```
### 解释

- `(rear + 1) % capacity`：计算队尾后移一位（循环意义上）的位置（若 `rear` 已在数组末尾，通过取模回到头部）。
- 若该位置等于 `front`，说明队列中已无空闲位置（仅剩预留的 1 个空位），即队列已满。
### 

**注意**：此逻辑基于 “预留一个空闲位置” 的设计。
若队列不预留空闲位置（即最大存储元素数等于 `capacity`），


则需额外变量记录元素个数，此时 “满” 的条件为 “元素个数等于 `capacity`”，但这种设计会增加内存开销，循环队列通常采用前者。

### 3. 为什么需要 `% capacity`？

因为队列是 “循环” 的，数组的首尾是相连的（比如数组索引到 `capacity-1` 后，下一个位置是 `0`）。

`% capacity` 的作用是处理 “边界循环”：当 `rear` 已经在数组的最后一个位置（索引 `capacity-1`）时，`rear + 1` 会等于 `capacity`，而 `capacity % capacity = 0`，刚好回到数组的开头（索引 `0`），符合循环的逻辑。



为什么删除 head 是 o（1）
Head=headnext


链式队列：为什么还是头跟头，尾跟尾


LinkedList; 是队列吗

为什么用链表做队列而不是顺序表？

