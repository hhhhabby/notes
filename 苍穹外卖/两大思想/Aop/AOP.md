# IOC 与 AOP 是 “基础支撑” 与 “功能实现” 的关系：

- **IOC 是前提**：日志切面类（如`LogAspect`）和被日志增强的目标对象（如`UserService`），都需要被 IOC 容器管理（加`@Component`等注解）——IOC 负责创建这些对象并纳入容器，为 AOP 提供 “可操作的目标”。
- **AOP 是手段**：基于 IOC 管理的对象，AOP 通过动态代理，在目标方法（如`UserService.save()`）执行前后，自动织入日志逻辑（如打印入参、耗时），实现 “不修改业务代码却能增强日志功能”。

简单说：IOC “管对象的出生”，AOP “用这些对象做增强”，两者配合让日志功能既能解耦又能自动生效。

# 什么是 aop？
AOP即面向切面编程，AOP 是 OOP（面向对象编程）的一种延续，二者互补，并不对立。

AOP 的目的是将OOP 不能很好地处理一些分散在多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等），这些行为通常被称为 **横切关注点（cross-cutting concerns）** 。如果我们在每个类或对象中都重复实现这些行为，那么会导致代码的冗余、复杂和难以维护。

OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性。

# Aop 可以干什么？
- 日志记录：自定义日志记录注解，利用 AOP，一行代码即可实现日志记录。
- 性能统计：利用 AOP 在目标方法的执行前后统计方法的执行时间，方便优化和分析。
- 事务管理：`@Transactional` 注解可以让 Spring 为我们进行事务管理比如回滚异常操作，免去了重复的事务管理逻辑。`@Transactional`注解就是基于 AOP 实现的。

# Aop 的实现

AOP 的常见实现方式有动态代理、字节码操作等方式。

Spring AOP 就是基于动态代理的。
如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 **JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 CGLIB 生成一个被代理对象的子类来作为代理，如下图所示：



# 实现 AOP 的具体代码
1. 切面类必须加@Aspect和@Component（缺一不可，@Component确保 Spring 能扫描到切面）；​

2. 切入点表达式必须正确（如包路径、类名不能写错，否则拦截不到方法）；​

3. 目标类（Controller/Service）必须被 Spring 管理（加@RestController/@Service），否则 AOP 无法生成代理对象；​

4. 若目标方法是private/final：CGLIB 代理会失效（无法继承），需改用 JDK 动态代理（目标类实现接口）或移除private/final修饰。




### 一、简答题（共 4 题）

1.  请简述 AOP（面向切面编程）的核心定义，以及它解决了传统 OOP（面向对象编程）中的什么问题？
2.  “连接点（待增强对象方法）
	”“切入点（指向简化的指针）” 
	”“通知（提取的简化方法）

什么时候用方法？
	/切面（通知+切入点）
	切面类（通知+切点表达式+类名）
3.  列举 Spring AOP 中支持的 5 种通知类型，并简要说明每种通知的执行时机。
4.  简述 AOP 动态代理的两种实现方式（JDK 动态代理、CGLIB 动态代理）的核心区别，以及 Spring AOP 默认使用哪种代理方式？
### 二、选择题（共 3 题，每题只有 1 个正确答案）
1.  下列关于 Spring AOP 与 AspectJ 的说法，错误的是（  ）
    A. Spring AOP 基于动态代理实现，AspectJ 基于编译期 / 类加载期织入实现
    B. Spring AOP 支持 AspectJ 的注解（如 @Aspect、@Before），但不依赖 AspectJ 核心包
    C. AspectJ 的功能比 Spring AOP 更完整，支持更多切入点表达式和通知类型

# 切点表达式

Execution (返回值+具体位置+参数 )


@Retention
@Annotation（）


方法加注解 @mylog


# 连接点
ProceedingJoinPoint(对象)------》@Aroud 通知
JoinPoint（对象）----->其他通知


对象干嘛的？
获得 id
获得方法签名
获得原方法名字
获得原方法参数
增强方法调用原方法
